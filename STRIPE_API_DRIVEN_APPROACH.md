# Stripe API-Driven Subscription Management

## Overview

Instead of relying on webhooks for subscription management, we use a **direct API approach** where state changes are handled immediately when they occur, and subscription data is synced directly from Stripe to our D1 database.

## Why This Approach?

### Problems with Webhook-Only Approach
1. **Local Development Issues**: Webhooks require ngrok or similar tunneling, which writes to local D1 while production reads from remote D1
2. **Eventual Consistency**: Webhooks can be delayed or fail, causing stale data
3. **Complex Debugging**: Hard to trace webhook failures across Stripe → ngrok → local server
4. **Rate Limits**: Free ngrok tier has request limits that can be exceeded during development

### Benefits of API-Driven Approach
1. **Immediate Consistency**: When user upgrades/cancels, we call Stripe API → update D1 immediately
2. **Works Everywhere**: Same code path for local development and production
3. **Simpler Testing**: No need for webhook tunneling or secret configuration
4. **Better UX**: User sees changes instantly without waiting for webhook processing
5. **Internal Usage Tracking**: We track API calls in D1 without repeatedly querying Stripe

## Architecture

### State Changes WE Control (Use Direct API)
- ✅ **User upgrades**: `/api/checkout` → Stripe Checkout → `/api/checkout/success` → Sync to D1
- ✅ **User cancels**: `/api/subscription/cancel` → Stripe API → Update D1
- ✅ **User reactivates**: `/api/subscription/reactivate` → Stripe API → Update D1
- ✅ **Usage tracking**: Stored in D1 `usage_logs` table, no Stripe queries needed

### External Events (Keep Webhooks)
- ⚠️ **Payment failures**: Stripe sends webhook when payment fails
- ⚠️ **Disputes/chargebacks**: Stripe initiates these
- ⚠️ **Subscription expiration**: Stripe ends subscription at period end
- ⚠️ **Invoice events**: Generated by Stripe on billing cycle

## Implementation

### 1. Checkout Flow

```typescript
// User clicks "Upgrade Now" button
[CheckoutButton] → POST /api/checkout
  ↓
  Create Stripe Checkout Session
  ↓
  Redirect user to Stripe Checkout
  ↓
  User completes payment
  ↓
  Redirect to /api/checkout/success?session_id=xxx
  ↓
  GET /api/checkout/success
  - Retrieve session from Stripe API
  - Update user tier in D1
  - Create subscription record in D1
  - Redirect to /settings/billing
```

**Key File**: `app/routes/api.checkout.success.ts`

### 2. Cancel Flow

```typescript
// User clicks "Cancel Subscription" button
[CancelButton] → POST /api/subscription/cancel
  ↓
  Get subscription from D1
  ↓
  Call Stripe API: subscriptions.update(id, { cancel_at_period_end: true })
  ↓
  Update D1: cancelAtPeriodEnd = true
  ↓
  Return success → Revalidate page
```

**Key File**: `app/routes/api.subscription.cancel.ts`

### 3. Reactivate Flow

```typescript
// User clicks "Reactivate Subscription" button
[CancelButton] → POST /api/subscription/reactivate
  ↓
  Get subscription from D1
  ↓
  Call Stripe API: subscriptions.update(id, { cancel_at_period_end: false })
  ↓
  Update D1: cancelAtPeriodEnd = false
  ↓
  Return success → Revalidate page
```

**Key File**: `app/routes/api.subscription.reactivate.ts`

### 4. Usage Tracking (Internal)

```typescript
// Every AI message sent
chatAction() → checkUserCredits()
  ↓
  Query D1 for user's tier and credits
  ↓
  If credits available:
    - Process message
    - Deduct 1 credit from D1
    - Log usage in D1 usage_logs table
  ↓
  No Stripe API calls needed
```

**Key File**: `app/lib/.server/credits/manager.ts`

## Database Schema

### D1 Tables

```sql
-- User subscription data
CREATE TABLE users (
  id TEXT PRIMARY KEY,
  tier TEXT NOT NULL DEFAULT 'free',
  credits INTEGER NOT NULL DEFAULT 10,
  stripe_customer_id TEXT,
  stripe_subscription_id TEXT,
  -- ...
);

-- Full subscription details
CREATE TABLE subscriptions (
  id TEXT PRIMARY KEY,              -- Stripe subscription ID
  user_id TEXT NOT NULL UNIQUE,
  stripe_customer_id TEXT NOT NULL,
  stripe_price_id TEXT NOT NULL,
  tier TEXT NOT NULL,
  status TEXT NOT NULL,
  current_period_start TIMESTAMP NOT NULL,
  current_period_end TIMESTAMP NOT NULL,
  cancel_at_period_end BOOLEAN NOT NULL DEFAULT 0,
  -- ...
);

-- Usage tracking (internal, no Stripe queries)
CREATE TABLE usage_logs (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id TEXT NOT NULL,
  credits_used INTEGER NOT NULL DEFAULT 1,
  timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  -- ...
);
```

## API Endpoints

| Endpoint | Method | Purpose | Syncs to D1? |
|----------|--------|---------|--------------|
| `/api/checkout` | POST | Create Stripe Checkout session | No |
| `/api/checkout/success` | GET | Process successful checkout | ✅ Yes |
| `/api/subscription/cancel` | POST | Cancel subscription at period end | ✅ Yes |
| `/api/subscription/reactivate` | POST | Reactivate cancelled subscription | ✅ Yes |
| `/api/billing/portal` | POST | Open Stripe Customer Portal | No |
| `/api/webhooks/stripe` | POST | Handle external Stripe events | ✅ Yes (for external events only) |

## Webhook Configuration (Minimal)

**Only subscribe to events we DON'T control:**

```
✅ invoice.payment_failed          - Payment declined
✅ customer.subscription.deleted   - Stripe expires subscription
✅ invoice.payment_succeeded       - Recurring payment success
```

**Remove events we handle via API:**

```
❌ checkout.session.completed      - Handled by /api/checkout/success
❌ customer.subscription.updated   - Handled by cancel/reactivate APIs
```

## Testing

### Local Development (No ngrok needed!)

1. **Test Upgrade Flow**:
   ```bash
   # Start dev server
   pnpm dev
   
   # Click "Upgrade Now" on /pricing
   # Complete Stripe checkout with test card: 4242 4242 4242 4242
   # Automatically redirected to /api/checkout/success
   # Check /settings/billing - should show "Plus" or "Pro"
   ```

2. **Test Cancel Flow**:
   ```bash
   # Go to /settings/billing
   # Click "Cancel Subscription"
   # Should see "Cancels on [date]"
   ```

3. **Test Reactivate Flow**:
   ```bash
   # After canceling, click "Reactivate Subscription"
   # Should see "Renews on [date]"
   ```

### Production

Same code paths work in production! No webhook configuration changes needed.

## Migration from Webhook-Only Approach

### Before (Webhook-Only)
```
User upgrades → Stripe → Webhook → Update D1 (eventual consistency)
```

### After (API-Driven)
```
User upgrades → Stripe Checkout → Our API → Update D1 (immediate consistency)
```

### Changes Required
- [x] Create `/api/checkout/success` route
- [x] Create `/api/subscription/cancel` route  
- [x] Create `/api/subscription/reactivate` route
- [x] Update checkout success URL to point to our API
- [x] Create `CancelButton` component
- [x] Update `BillingPanel` to use cancel/reactivate buttons
- [x] Simplify webhook handler to only handle external events

## Advantages for Your Use Case

1. **No Database Mismatch**: Direct API calls work with whatever database is bound (local or remote)
2. **Instant Feedback**: User sees tier change immediately after payment
3. **Simpler Debugging**: Console logs show exact flow, no webhook guessing
4. **Cost Effective**: Internal usage tracking doesn't hit Stripe API
5. **Reliable**: No webhook delivery failures or delays

## Summary

This approach treats Stripe as the **source of truth** for payment data, but we **actively sync** when WE initiate changes (upgrades, cancels) rather than passively waiting for webhooks. Webhooks are reserved for events Stripe initiates (payment failures, disputes).

Result: Better UX, simpler code, works everywhere, no ngrok needed for development!

